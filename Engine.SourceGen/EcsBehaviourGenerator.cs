using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace Engine.SourceGen;

[Generator(LanguageNames.CSharp)]
public sealed class EcsBehaviourGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext ctx)
    {
        var candidates = ctx.SyntaxProvider.CreateSyntaxProvider(
            static (node, _) => node is StructDeclarationSyntax sds && sds.AttributeLists.Count > 0,
            static (context, _) =>
            {
                var sds = (StructDeclarationSyntax)context.Node;
                var type = context.SemanticModel.GetDeclaredSymbol(sds) as INamedTypeSymbol;
                if (type is null) return null;
                foreach (var a in type.GetAttributes())
                    if (a.AttributeClass?.ToDisplayString() == "Engine.Behaviour.BehaviourAttribute")
                        return type;
                return null;
            })
            .Where(s => s is not null)!
            .Collect();

        var compilationAndTypes = ctx.CompilationProvider.Combine(candidates);
        ctx.RegisterSourceOutput(compilationAndTypes, (spc, pair) =>
        {
            var (compilation, types) = pair;
            var behaviours = new List<BehaviourModel>();
            foreach (INamedTypeSymbol t in types.OfType<INamedTypeSymbol>().Distinct(SymbolEqualityComparer.Default))
            {
                var model = BuildModel(compilation, t);
                if (model is not null) behaviours.Add(model);
            }

            // Emit per-behaviour systems
            foreach (var b in behaviours)
                spc.AddSource($"{b.SafeName}.g.cs", GenBehaviourSystems(b));

            // Emit registration plugin
            spc.AddSource("GeneratedBehavioursPlugin.g.cs", GenPlugin(behaviours));
        });
    }

    private static BehaviourModel? BuildModel(Compilation compilation, INamedTypeSymbol type)
    {
        var ns = type.ContainingNamespace.IsGlobalNamespace ? "Engine.Generated" : type.ContainingNamespace.ToDisplayString();
        var name = type.Name;
        var safe = name + "_Generated";
        var methods = new List<StageMethod>();

        foreach (var m in type.GetMembers().OfType<IMethodSymbol>())
        {
            Stage? stage = GetStage(m);
            if (stage is null) continue;
            // Support instance and static methods
            var filters = GetFilters(m);
            methods.Add(new StageMethod
            {
                Stage = stage.Value,
                IsStatic = m.IsStatic,
                MethodContainer = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
                MethodName = m.Name,
                Filters = filters
            });
        }

        return new BehaviourModel
        {
            Namespace = ns,
            Name = name,
            SafeName = safe,
            BehaviourFqn = type.ToDisplayString(SymbolDisplayFormat.FullyQualifiedFormat),
            StageMethods = methods
        };
    }

    private static Stage? GetStage(IMethodSymbol m)
    {
        foreach (var a in m.GetAttributes())
        {
            var n = a.AttributeClass?.ToDisplayString();
            if (n == "Engine.Behaviour.OnStartupAttribute") return Stage.Startup;
            if (n == "Engine.Behaviour.OnFirstAttribute") return Stage.First;
            if (n == "Engine.Behaviour.OnPreUpdateAttribute") return Stage.PreUpdate;
            if (n == "Engine.Behaviour.OnUpdateAttribute") return Stage.Update;
            if (n == "Engine.Behaviour.OnPostUpdateAttribute") return Stage.PostUpdate;
            if (n == "Engine.Behaviour.OnRenderAttribute") return Stage.Render;
            if (n == "Engine.Behaviour.OnLastAttribute") return Stage.Last;
        }
        return null;
    }

    private static Filters GetFilters(IMethodSymbol m)
    {
        var with = new List<string>();
        var without = new List<string>();
        var changed = new List<string>();
        foreach (var a in m.GetAttributes())
        {
            var n = a.AttributeClass?.ToDisplayString();
            if (n == "Engine.Behaviour.WithAttribute")
                with.AddRange(a.ConstructorArguments[0].Values.Select(v => v.Value!.ToString()!));
            else if (n == "Engine.Behaviour.WithoutAttribute")
                without.AddRange(a.ConstructorArguments[0].Values.Select(v => v.Value!.ToString()!));
            else if (n == "Engine.Behaviour.ChangedAttribute")
                changed.AddRange(a.ConstructorArguments[0].Values.Select(v => v.Value!.ToString()!));
        }
        return new Filters(with, without, changed);
    }

    private static string GenBehaviourSystems(BehaviourModel b)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine($"namespace {b.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"internal static class {b.SafeName}");
        sb.AppendLine("{");
        sb.AppendLine("    public static void Register(Engine.App app)");
        sb.AppendLine("    {");
        foreach (var g in b.StageMethods.GroupBy(m => m.Stage))
        {
            sb.AppendLine($"        app.AddSystem(Engine.Stage.{g.Key}, {b.SafeName}_{g.Key});");
        }
        sb.AppendLine("    }");
        foreach (var m in b.StageMethods)
        {
            sb.AppendLine();
            sb.AppendLine($"    private static void {b.SafeName}_{m.Stage}(Engine.World world)");
            sb.AppendLine("    {");
            sb.AppendLine("        var ecs = world.Resource<Engine.EcsWorld>();");
            sb.AppendLine("        var ctx = new Engine.Behaviour.BehaviourContext(world);");
            if (m.IsStatic)
            {
                sb.AppendLine($"        {m.MethodContainer}.{m.MethodName}(ctx);");
                sb.AppendLine("        return;");
                sb.AppendLine("    }");
                continue;
            }
            // non-static: iterate entities
            var loopHeader = GenForeachHeader(b.BehaviourFqn, m.Filters.With);
            sb.AppendLine(loopHeader);
            // Filters: Without / Changed
            sb.Append(GenFilterChecks(m.Filters));
            sb.AppendLine("            ctx.EntityId = entity;");
            sb.AppendLine($"            behv.{m.MethodName}(ctx);");
            sb.AppendLine($"            ecs.Update<{b.BehaviourFqn}>(entity, behv);");
            sb.AppendLine("        }");
            sb.AppendLine("    }");
        }
        sb.AppendLine("}");
        return sb.ToString();
    }

    private static string GenForeachHeader(string behaviourFqn, IReadOnlyList<string> with)
    {
        return with.Count switch
        {
            0 => $"        foreach (var (entity, behv) in ecs.Query<{behaviourFqn}>())\n        {{",
            1 => $"        foreach (var (entity, behv, __w1) in ecs.Query<{behaviourFqn}, {with[0]}>())\n        {{",
            2 => $"        foreach (var (entity, behv, __w1, __w2) in ecs.Query<{behaviourFqn}, {with[0]}, {with[1]}>())\n        {{",
            _ => $"        foreach (var (entity, behv) in ecs.Query<{behaviourFqn}>())\n        {{",
        };
    }

    private static string GenFilterChecks(Filters f)
    {
        var sb = new StringBuilder();
        foreach (var wout in f.Without)
            sb.AppendLine($"            if (ecs.Has<{wout}>(entity)) continue;");
        foreach (var ch in f.Changed)
            sb.AppendLine($"            if (!ecs.Changed<{ch}>(entity)) continue;");
        return sb.ToString();
    }

    private static string GenPlugin(IEnumerable<BehaviourModel> behaviours)
    {
        var sb = new StringBuilder();
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("namespace Engine.Generated;");
        sb.AppendLine("public sealed class GeneratedBehavioursPlugin : Engine.IPlugin");
        sb.AppendLine("{");
        sb.AppendLine("    public void Build(Engine.App app)");
        sb.AppendLine("    {");
        foreach (var b in behaviours)
            sb.AppendLine($"        global::{b.Namespace}.{b.SafeName}.Register(app);");
        sb.AppendLine("    }");
        sb.AppendLine("}");
        return sb.ToString();
    }

    private enum Stage { Startup, First, PreUpdate, Update, PostUpdate, Render, Last }
    private sealed record Filters(IReadOnlyList<string> With, IReadOnlyList<string> Without, IReadOnlyList<string> Changed);
    private sealed record StageMethod
    {
        public Stage Stage { get; init; }
        public bool IsStatic { get; init; }
        public string MethodContainer { get; init; } = string.Empty;
        public string MethodName { get; init; } = string.Empty;
        public Filters Filters { get; init; } = new Filters(Array.Empty<string>(), Array.Empty<string>(), Array.Empty<string>());
    }
    private sealed record BehaviourModel
    {
        public string Namespace { get; init; } = "Engine.Generated";
        public string Name { get; init; } = string.Empty;
        public string SafeName { get; init; } = string.Empty;
        public string BehaviourFqn { get; init; } = string.Empty;
        public List<StageMethod> StageMethods { get; init; } = new();
    }
}
